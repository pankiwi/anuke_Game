function reSize() {
  c.canvas.width = c.canvas.width < innerWidth ? innerWidth : c.canvas.width
  c.canvas.height = c.canvas.height < innerHeight ? innerHeight : c.canvas.height
}

const c = document.querySelector("canvas").getContext("2d")

let MAX_X_GAME = c.canvas.width
let MAX_Y_GAME = c.canvas.height
let star_game = false
let debug = false
let points = 0
let bulletsObject = []
let particleObject = []
let enemyObject = []
/*
    

    
    */

const player = new PlayerEntity(MAX_X_GAME / 2, MAX_Y_GAME / 2, imgs.anuke, 100, 60)


let counterEnemy = 0
let round = 1
let stat_dif = 10
let spawTime = 2000
let enemys = 0
let cir = new cicle(1,1,50)

//by Skatnext
// rand: devuelve un numero random entre el primer y el segudo parametro

function rand(min, max) { const argc = arguments.length; if (argc === 0) { min = 0;
    max = 2147483647; } else if (argc === 1) { throw new Error('Warning: rand() expects exactly 2 parameters, 1 given'); } return Math.floor(Math.random() * (max - min + 1)) + min; }

function spawEnemy(){
  let x,y,radiusEnemy,speed,angle
  radiusEnemy = 60
  
  if(Math.random() < 0.5){
    x = Math.random() < 0.5? 0 - radiusEnemy: MAX_X_GAME + radiusEnemy
    y = Math.random() * MAX_Y_GAME
  }else{
    y = Math.random() < 0.5? 0 - radiusEnemy: MAX_Y_GAME + radiusEnemy
    x = Math.random() * MAX_X_GAME
  }
  
  angle = Math.atan2(MAX_Y_GAME/2 - y,MAX_X_GAME/2 - x) * 180 / Math.PI
  speed = Math.floor(radiusEnemy/ 30)
  console.log(x + "/ y:" + y + "/ r:" + radiusEnemy + "/ s:" + speed + "/ a:" + angle + "/rs:" + radiusEnemy/ 8)
  enemyObject.push( new enemy(imgs.juction,x,y,radiusEnemy,speed,angle,radiusEnemy*2))
  enemys++
}




let interval_
let Interval = function(){
  interval_ = setInterval(() => {
    spawEnemy()
  },spawTime)
}
function removeObject(index, array = []) {
  array.splice(index, 1)
}

function game() {

  if (star_game) {
    cir.update()
    if(enemys >= stat_dif * round){
      clearInterval(interval_)
      enemys = 0
      spawTime -= 50
    }
    bulletsObject.forEach((bullet, indexBullet) => {
      bullet.update()

      if (bullet.x - bullet.radius > MAX_X_GAME) {
        removeObject(indexBullet, bulletsObject)
      }
      if (bullet.x + bullet.radius < 0) {
        removeObject(indexBullet, bulletsObject)
      }

      if (bullet.y - bullet.radius > MAX_Y_GAME) {
        removeObject(indexBullet, bulletsObject)
      }
      if (bullet.y + bullet.radius < 0) {
        removeObject(indexBullet, bulletsObject)
      }
    })
    enemyObject.forEach((enemy, index_enemy) => {
      enemy.update()
      const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y)

      if (dist - enemy.radius - player.radius < 1) {
        player.dead = true

      }

      bulletsObject.forEach((bullet_, index_bullet) => {
        const dist = Math.hypot(bullet_.x - enemy.x, bullet_.y - enemy.y)

        if (dist - enemy.radius - bullet_.radius < 1) {
          bullet_.hit(index_bullet, enemy, index_enemy)
        }
      })
    })

    particleObject.forEach((particle, index_particle) => {
      if (particle.alfa <= 0) {
        removeObject(index_particle, particleObject)
      } else {
        particle.update()
      }
    })
    /**/
  }

}
let time = 150
let i = 0
let animationUI = [UIConfig_.UIS[2], UIConfig_.UIS[3], UIConfig_.UIS[4], UIConfig_.UIS[5], UIConfig_.UIS[6], UIConfig_.UIS[7], UIConfig_.UIS[8], UIConfig_.UIS[9], UIConfig_.UIS[10], UIConfig_.UIS[11]]

function animation() {
  requestAnimationFrame(animation)

  /*clear*/
  c.fillStyle = "rgba(255,255,255,0.3"
  c.fillRect(0, 0, c.canvas.width, c.canvas.height)
  if (star_game) {
    game()
  } else {
    time += 1
    if (time >= 150) {
      time = 0

      if (animationUI[i]) {
        animationUI[i].enable = true
      }
      if (animationUI[i - 1]) {
        animationUI[i - 1].enable = false
      }
      i++
      if (i >= animationUI.length) {
        star_game = true
        i = 0
 //       console.log(rand(1))
       // spawEnemy()
       Interval()
        UIConfig_.UIS[1].enable = true
        animationUI.forEach((ui) => {
          ui.enable = false
        })
        
      }
    }
  }
  player.update()
  /*draw UI*/
   drawTxt(c, c.canvas.width / 2, c.canvas.height / 2, 200, 50, "black",interval_ + "/" + enemys, 1)
  //player.update()
  UIConfig_.drawAllUI()

}

window.onload = () => {
  animation();
}

c.canvas.addEventListener("click", (event) => {
  event.preventDefault()
  if (star_game) {
    
  //  Sound_source_.playSound("shot", 1)
  cir.setCoords(event.clientY,event.clientX)
    let angle = Math.atan2(event.clientY - MAX_Y_GAME / 2, event.clientX - MAX_X_GAME / 2) * 180 / Math.PI;
   
    bulletsObject.push(new bullet(imgs.router, MAX_X_GAME / 2, MAX_Y_GAME / 2, 10, 15, angle, 30))
  } else {
    i = animationUI.length
  }
})

window.addEventListener("resize",reSize)